<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Wajah Aneka - Game Match-3 dengan Emoji</title>
<meta name="description" content="Game match-3 dengan emoji wajah yang menyenangkan">
<meta name="theme-color" content="#ff6b6b">
<style>
*{box-sizing:border-box;margin:0;padding:0;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;touch-action:manipulation;-webkit-tap-highlight-color:transparent}
body{background:linear-gradient(135deg,#ff9a9e 0%,#fad0c4 100%);min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:20px;color:#333;overflow-x:hidden}
header{text-align:center;margin-bottom:20px;width:100%;max-width:500px}
h1{font-size:2.5rem;color:#ff6b6b;text-shadow:2px 2px 4px rgba(0,0,0,0.2);margin-bottom:10px}
.game-info{display:flex;justify-content:space-between;width:100%;max-width:500px;margin-bottom:20px;background-color:rgba(255,255,255,0.9);padding:15px 20px;border-radius:15px;box-shadow:0 5px 15px rgba(0,0,0,0.1)}
.score-container,.level-container{text-align:center;flex:1}
.score-label,.level-label{font-size:1rem;color:#666;margin-bottom:5px}
.score,.level{font-size:2rem;font-weight:bold;color:#ff6b6b}
.target-container{text-align:center;flex:1}
.target-label{font-size:1rem;color:#666;margin-bottom:5px}
.target{font-size:1.5rem;font-weight:bold;color:#ff6b6b;display:flex;justify-content:center;align-items:center;gap:5px}
.game-board{display:grid;grid-template-columns:repeat(8,1fr);gap:5px;width:100%;max-width:500px;aspect-ratio:1/1;background-color:rgba(255,255,255,0.9);padding:15px;border-radius:15px;box-shadow:0 5px 15px rgba(0,0,0,0.1);margin-bottom:20px;touch-action:none;position:relative}
.emoji{display:flex;justify-content:center;align-items:center;font-size:1.8rem;border-radius:10px;background-color:rgba(255,255,255,0.7);transition:all 0.2s ease;user-select:none;cursor:pointer;box-shadow:0 2px 5px rgba(0,0,0,0.05);position:relative;min-height:40px}
.emoji:hover{background-color:rgba(255,255,255,0.9);transform:scale(1.05)}
.emoji.selected{background-color:#ffd166;transform:scale(1.1);box-shadow:0 0 10px rgba(255,209,102,0.7)}
.emoji.matched{animation:matched 0.45s ease-out forwards}
@keyframes matched{0%{transform:scale(1);opacity:1}50%{transform:scale(1.2);opacity:0.7}100%{transform:scale(0);opacity:0}}
.controls{display:flex;gap:15px;margin-bottom:20px;width:100%;max-width:500px}
button{flex:1;padding:15px 20px;border:none;border-radius:50px;background:linear-gradient(to right,#ff6b6b,#ff9a9e);color:white;font-size:1rem;font-weight:bold;cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,0.2);transition:all 0.2s ease}
button:hover{transform:translateY(-3px);box-shadow:0 6px 12px rgba(0,0,0,0.2)}
button:active{transform:translateY(0);box-shadow:0 2px 4px rgba(0,0,0,0.2)}
button:disabled{opacity:0.7;cursor:not-allowed;transform:none}
.instructions{max-width:500px;background-color:rgba(255,255,255,0.9);padding:20px;border-radius:15px;box-shadow:0 5px 15px rgba(0,0,0,0.1);margin-bottom:20px}
.instructions h2{color:#ff6b6b;margin-bottom:15px;text-align:center}
.instructions p{margin-bottom:10px;line-height:1.5}
.swipe-info{background-color:rgba(255,255,255,0.9);padding:12px 20px;border-radius:50px;margin-bottom:15px;text-align:center;box-shadow:0 3px 8px rgba(0,0,0,0.1)}
footer{margin-top:auto;text-align:center;padding:20px;color:#666;font-size:0.9rem}
@keyframes appear{from{transform:scale(0);opacity:0}to{transform:scale(1);opacity:1}}
.emoji.new{animation:appear 0.25s ease-out forwards}
.game-board.processing{opacity:0.7;pointer-events:none}
.level-up-modal{position:fixed;top:0;left:0;width:100%;height:100%;background-color:rgba(0,0,0,0.7);display:flex;justify-content:center;align-items:center;z-index:1000;opacity:0;pointer-events:none;transition:opacity 0.3s ease}
.level-up-modal.active{opacity:1;pointer-events:all}
.modal-content{background:white;padding:30px;border-radius:20px;text-align:center;max-width:80%;box-shadow:0 10px 25px rgba(0,0,0,0.2)}
.modal-content h2{color:#ff6b6b;margin-bottom:15px;font-size:1.8rem}
.modal-content p{margin-bottom:20px;font-size:1.2rem;color:#555}
.modal-emoji{font-size:3rem;margin:15px 0}
.combo-notification{position:absolute;font-size:1.5rem;font-weight:bold;color:#ff6b6b;animation:floatUp 1s ease-out forwards;pointer-events:none;z-index:100}
@keyframes floatUp{0%{transform:translateY(0);opacity:1}100%{transform:translateY(-50px);opacity:0}}
.drag-line{position:absolute;background-color:rgba(255,209,102,0.7);pointer-events:none;z-index:50;transform-origin:0 0}
.highlight{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(255,255,255,0.5);border-radius:10px;animation:pulse 1s infinite}
@keyframes pulse{0%{opacity:0.5}50%{opacity:0.8}100%{opacity:0.5}}
.progress-bar{width:100%;height:10px;background-color:#eee;border-radius:5px;margin-top:5px;overflow:hidden}
.progress{height:100%;background:linear-gradient(to right,#ff6b6b,#ff9a9e);border-radius:5px;transition:width 0.3s ease}
.moves-container{text-align:center;flex:1}
.moves-label{font-size:1rem;color:#666;margin-bottom:5px}
.moves{font-size:1.5rem;font-weight:bold;color:#ff6b6b}
@media (max-width:520px){.game-board{padding:10px;gap:4px}.emoji{font-size:1.5rem}h1{font-size:2rem}.score,.level{font-size:1.8rem}.controls{flex-direction:column}button{width:100%}}
@media (max-width:400px){.emoji{font-size:1.3rem}.game-info{padding:12px}.score,.level{font-size:1.6rem}.instructions{padding:15px}}
@media (max-height:700px){header{margin-bottom:15px}.game-info{margin-bottom:15px}.instructions{display:none}}
</style>
</head>
<body>
<header><h1>Wajah Aneka</h1><p>Game match-3 dengan emoji wajah yang menyenangkan!</p></header>
<div class="game-info">
  <div class="score-container"><div class="score-label">Poin</div><div class="score">0</div></div>
  <div class="level-container"><div class="level-label">Level</div><div class="level">1</div></div>
  <div class="moves-container"><div class="moves-label">Gerakan</div><div class="moves">0</div></div>
</div>
<div class="progress-bar"><div class="progress" id="progressBar" style="width:0%"></div></div>
<div class="swipe-info">Geser emoji untuk membuat match minimal 3</div>
<div class="game-board" id="gameBoard" aria-label="Papan Permainan"></div>
<div class="controls">
  <button id="hintBtn">Bantuan</button>
  <button id="shuffleBtn">Acak Ulang</button>
</div>
<div class="instructions">
  <h2>Cara Bermain</h2>
  <p>1. Geser emoji ke kiri/kanan/atas/bawah untuk menukar posisinya</p>
  <p>2. Buat garis horizontal atau vertikal minimal 3 emoji yang sama</p>
  <p>3. Emoji yang match akan hilang dan emoji di atasnya akan turun</p>
  <p>4. Dapatkan poin dan naik level setiap 1000 poin</p>
</div>
<div class="level-up-modal" id="levelUpModal">
  <div class="modal-content">
    <h2>Selamat!</h2>
    <div class="modal-emoji">üéâ</div>
    <p>Anda mencapai level <span id="newLevel">1</span>!</p>
    <button id="modalCloseBtn">Lanjutkan</button>
  </div>
</div>
<footer><p>Game Wajah Aneka &copy; 2023 - Mainkan dan bagikan!</p></footer>
<script>
// Konstanta game
const basicEmojis = ['üòÅ', 'üò©', 'üòù', 'üò≥', 'üò¢', 'üòç', 'ü§î', 'üòé'];
const BOARD_SIZE = 8;
const MIN_MATCH = 3;
const POINTS_PER_MATCH = 100;
const LEVEL_UP_SCORE = 1000;
const COMBO_MULTIPLIER = 0.2; // 20% tambahan poin per kombo

// Variabel game state
let score = 0;
let level = 1;
let board = [];
let isProcessing = false;
let selectedEmoji = null;
let dragStart = null;
let dragLine = null;
let comboCount = 0;
let moves = 0;

// Untuk deteksi perubahan saat fill (agar dapat beri class .new)
let previousBoardSnapshot = null;

// Elemen DOM
const gameBoard = document.getElementById('gameBoard');
const scoreDisplay = document.querySelector('.score');
const levelDisplay = document.querySelector('.level');
const movesDisplay = document.querySelector('.moves');
const hintBtn = document.getElementById('hintBtn');
const shuffleBtn = document.getElementById('shuffleBtn');
const levelUpModal = document.getElementById('levelUpModal');
const newLevelDisplay = document.getElementById('newLevel');
const modalCloseBtn = document.getElementById('modalCloseBtn');
const progressBar = document.getElementById('progressBar');

// Inisialisasi game
function initGame() {
  createBoard();
  updateDisplay();
  updateMoves();

  // Event listeners
  hintBtn.addEventListener('click', showHint);
  shuffleBtn.addEventListener('click', shuffleBoard);
  modalCloseBtn.addEventListener('click', closeModal);

  // Event untuk drag emoji (mobile dan desktop)
  // Kelola start pada board, move pada document agar tetap sensitif ketika keluar elemen
  gameBoard.addEventListener('mousedown', handleDragStart);
  gameBoard.addEventListener('touchstart', handleDragStart, { passive: false });
  document.addEventListener('mousemove', handleDragMove);
  document.addEventListener('touchmove', handleDragMove, { passive: false });
  document.addEventListener('mouseup', handleDragEnd);
  document.addEventListener('touchend', handleDragEnd);

  // Buat elemen untuk garis drag (untuk visual, kini tidak digunakan intensif)
  dragLine = document.createElement('div');
  dragLine.className = 'drag-line';
  dragLine.style.display = 'none';
  gameBoard.appendChild(dragLine);
}

// Membuat papan game (pasti tanpa match di awal dan ada valid moves)
function createBoard() {
  board = [];
  // isi board sampai valid: tidak ada immediate matches & ada moves valid
  do {
    for (let r = 0; r < BOARD_SIZE; r++) {
      board[r] = [];
      for (let c = 0; c < BOARD_SIZE; c++) {
        board[r][c] = getRandomEmoji();
      }
    }
  } while (checkAllMatches().length > 0 || !hasValidMovesForBoard(board));

  // Render DOM grid - elemen tetap sama sepanjang permainan (dataset posisi statis)
  gameBoard.innerHTML = '';
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      const el = createEmojiElement(board[r][c], r, c);
      gameBoard.appendChild(el);
    }
  }
}

// Membuat elemen emoji
function createEmojiElement(emoji, row, col) {
  const emojiElement = document.createElement('div');
  emojiElement.className = 'emoji';
  emojiElement.textContent = emoji || '';
  emojiElement.dataset.row = row;
  emojiElement.dataset.col = col;
  // accessibility
  emojiElement.setAttribute('role', 'button');
  emojiElement.setAttribute('aria-label', `Sel ${row + 1} kolom ${col + 1}`);
  return emojiElement;
}

// Mendapatkan emoji random
function getRandomEmoji() {
  const randomIndex = Math.floor(Math.random() * basicEmojis.length);
  return basicEmojis[randomIndex];
}

// Handler untuk memulai drag
function handleDragStart(event) {
  if (isProcessing) return;

  let element;
  let clientX, clientY;
  if (event.type === 'mousedown') {
    element = event.target;
    clientX = event.clientX;
    clientY = event.clientY;
  } else if (event.type === 'touchstart') {
    event.preventDefault();
    const touch = event.touches[0];
    clientX = touch.clientX;
    clientY = touch.clientY;
    element = document.elementFromPoint(clientX, clientY);
  } else return;

  if (!element || !element.classList.contains('emoji')) return;

  selectedEmoji = element;
  const row = parseInt(element.dataset.row, 10);
  const col = parseInt(element.dataset.col, 10);
  dragStart = { row, col, x: clientX, y: clientY };

  element.classList.add('selected');
}

// Handler untuk pergerakan drag
function handleDragMove(event) {
  if (!dragStart || !selectedEmoji || isProcessing) return;

  let clientX, clientY;
  if (event.type === 'mousemove') {
    clientX = event.clientX;
    clientY = event.clientY;
  } else if (event.type === 'touchmove') {
    event.preventDefault();
    const touch = event.touches[0];
    clientX = touch.clientX;
    clientY = touch.clientY;
  } else return;

  const deltaX = clientX - dragStart.x;
  const deltaY = clientY - dragStart.y;
  const absDeltaX = Math.abs(deltaX);
  const absDeltaY = Math.abs(deltaY);

  if (absDeltaX < 20 && absDeltaY < 20) return;

  let direction = null;
  if (absDeltaX > absDeltaY) {
    direction = deltaX > 0 ? 'right' : 'left';
  } else {
    direction = deltaY > 0 ? 'down' : 'up';
  }

  let targetRow = dragStart.row;
  let targetCol = dragStart.col;

  switch (direction) {
    case 'up': targetRow--; break;
    case 'down': targetRow++; break;
    case 'left': targetCol--; break;
    case 'right': targetCol++; break;
  }

  if (targetRow < 0 || targetRow >= BOARD_SIZE || targetCol < 0 || targetCol >= BOARD_SIZE) {
    return;
  }

  // lakukan swap
  // disable further input sampai selesai
  swapEmojis(dragStart.row, dragStart.col, targetRow, targetCol);
  // langsung reset selection visual (actual logic akan memproses)
  if (selectedEmoji) selectedEmoji.classList.remove('selected');
  selectedEmoji = null;
  dragStart = null;
}

// Handler untuk mengakhiri drag
function handleDragEnd() {
  if (selectedEmoji) selectedEmoji.classList.remove('selected');
  selectedEmoji = null;
  dragStart = null;
  if (dragLine) dragLine.style.display = 'none';
}

// Menukar dua emoji (dengan validasi match)
function swapEmojis(row1, col1, row2, col2) {
  if (isProcessing) return;
  isProcessing = true;
  gameBoard.classList.add('processing');

  // buat snapshot previous untuk animasi 'new'
  previousBoardSnapshot = JSON.parse(JSON.stringify(board));

  // Tukar di board
  const temp = board[row1][col1];
  board[row1][col1] = board[row2][col2];
  board[row2][col2] = temp;

  // Update tampilan
  updateBoardView();

  setTimeout(() => {
    const matches = checkAllMatches();
    if (matches.length > 0) {
      moves++;
      updateMoves();
      processMatches(matches);
    } else {
      // kembalikan swap karena tidak menghasilkan match
      board[row2][col2] = board[row1][col1];
      board[row1][col1] = temp;
      updateBoardView();
      isProcessing = false;
      gameBoard.classList.remove('processing');
    }
  }, 180);
}

// Memproses match yang ditemukan
function processMatches(matches) {
  comboCount++;

  // tandai matched di DOM dan set board ke null
  matches.forEach(({ row, col }) => {
    if (board[row] && board[row][col] !== null) {
      board[row][col] = null;
      const element = document.querySelector(`.emoji[data-row="${row}"][data-col="${col}"]`);
      if (element) element.classList.add('matched');
    }
  });

  // Hitung poin (count unique matches)
  const uniqueCoords = Array.from(new Set(matches.map(m => `${m.row},${m.col}`)));
  const totalMatches = uniqueCoords.length;
  const comboBonus = 1 + (comboCount - 1) * COMBO_MULTIPLIER;
  const points = Math.round(totalMatches * POINTS_PER_MATCH * comboBonus);

  if (comboCount > 1) showComboNotification(comboCount, points);
  addScore(points);

  // tunggu animasi matched selesai lalu isi papan
  setTimeout(() => fillBoard(), 380);
}

// Mengisi papan setelah match
function fillBoard() {
  // buat snapshot sebelum fill untuk tahu mana yang baru
  const beforeFill = JSON.parse(JSON.stringify(board));

  // Turunkan emoji dari atas per kolom
  for (let col = 0; col < BOARD_SIZE; col++) {
    let emptySpaces = 0;
    for (let row = BOARD_SIZE - 1; row >= 0; row--) {
      if (board[row][col] === null) {
        emptySpaces++;
      } else if (emptySpaces > 0) {
        board[row + emptySpaces][col] = board[row][col];
        board[row][col] = null;
      }
    }
    // isi empty spaces di bagian atas
    for (let row = 0; row < emptySpaces; row++) {
      board[row][col] = getRandomEmoji();
    }
  }

  // Update tampilan dan beri class .new pada cell yang berubah dari null -> emoji
  updateBoardView(beforeFill);

  // cek match lagi setelah pengisian
  setTimeout(() => {
    const newMatches = checkAllMatches();
    if (newMatches.length > 0) {
      processMatches(newMatches);
    } else {
      comboCount = 0;
      isProcessing = false;
      gameBoard.classList.remove('processing');

      // Jika tidak ada moves valid, acak ulang papan
      if (!hasValidMoves()) {
        setTimeout(() => {
          alert('Tidak ada gerakan yang valid! Mengacak ulang papan...');
          shuffleBoard();
        }, 200);
      }
    }
  }, 220);
}

// Memperbarui tampilan papan
// optional prevSnapshot supaya bisa beri kelas .new
function updateBoardView(prevSnapshot = null) {
  const emojiElements = gameBoard.querySelectorAll('.emoji');
  emojiElements.forEach(element => {
    const row = parseInt(element.dataset.row, 10);
    const col = parseInt(element.dataset.col, 10);
    const value = board[row] && board[row][col] ? board[row][col] : '';
    element.textContent = value;
    element.classList.remove('selected', 'matched');

    // tambahkan .new jika sebelumnya null atau berbeda dan sekarang ada value
    if (prevSnapshot) {
      const was = prevSnapshot[row] ? prevSnapshot[row][col] : null;
      const isNow = board[row] ? board[row][col] : null;
      if ((was === null || was === undefined) && isNow) {
        element.classList.add('new');
        // hapus class new setelah anim selesai
        setTimeout(() => element.classList.remove('new'), 400);
      }
    }
  });
}

// Memeriksa semua match di papan (mengembalikan list sel yang harus dihapus)
function checkAllMatches() {
  const matches = [];

  // horizontal
  for (let row = 0; row < BOARD_SIZE; row++) {
    let col = 0;
    while (col < BOARD_SIZE - (MIN_MATCH - 1)) {
      const emoji = board[row][col];
      if (!emoji) { col++; continue; }
      let matchLen = 1;
      while (col + matchLen < BOARD_SIZE && board[row][col + matchLen] === emoji) matchLen++;
      if (matchLen >= MIN_MATCH) {
        for (let k = 0; k < matchLen; k++) matches.push({ row, col: col + k });
      }
      col += matchLen;
    }
  }

  // vertical
  for (let col = 0; col < BOARD_SIZE; col++) {
    let row = 0;
    while (row < BOARD_SIZE - (MIN_MATCH - 1)) {
      const emoji = board[row][col];
      if (!emoji) { row++; continue; }
      let matchLen = 1;
      while (row + matchLen < BOARD_SIZE && board[row + matchLen][col] === emoji) matchLen++;
      if (matchLen >= MIN_MATCH) {
        for (let k = 0; k < matchLen; k++) matches.push({ row: row + k, col });
      }
      row += matchLen;
    }
  }

  // hapus duplikat
  return Array.from(new Set(matches.map(m => `${m.row},${m.col}`))).map(coord => {
    const [r, c] = coord.split(',').map(Number);
    return { row: r, col: c };
  });
}

// Memeriksa apakah masih ada moves yang valid pada board saat ini (global)
function hasValidMoves() {
  return hasValidMovesForBoard(board);
}

// Cek moves valid untuk board tertentu (tanpa side-effects)
function hasValidMovesForBoard(boardToCheck) {
  // coba semua swap tetangga
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      // swap kanan
      if (c < BOARD_SIZE - 1) {
        swapCells(boardToCheck, r, c, r, c + 1);
        if (checkMatchesOnBoard(boardToCheck).length > 0) {
          swapCells(boardToCheck, r, c, r, c + 1);
          return true;
        }
        swapCells(boardToCheck, r, c, r, c + 1);
      }
      // swap bawah
      if (r < BOARD_SIZE - 1) {
        swapCells(boardToCheck, r, c, r + 1, c);
        if (checkMatchesOnBoard(boardToCheck).length > 0) {
          swapCells(boardToCheck, r, c, r + 1, c);
          return true;
        }
        swapCells(boardToCheck, r, c, r + 1, c);
      }
    }
  }
  return false;
}

// helper swap pada board yang diberikan
function swapCells(b, r1, c1, r2, c2) {
  const t = b[r1][c1];
  b[r1][c1] = b[r2][c2];
  b[r2][c2] = t;
}

// Memeriksa match pada papan tertentu (mengembalikan list sel)
function checkMatchesOnBoard(boardToCheck) {
  const matches = [];
  // horizontal
  for (let row = 0; row < BOARD_SIZE; row++) {
    let col = 0;
    while (col < BOARD_SIZE - (MIN_MATCH - 1)) {
      const emoji = boardToCheck[row][col];
      if (!emoji) { col++; continue; }
      let matchLen = 1;
      while (col + matchLen < BOARD_SIZE && boardToCheck[row][col + matchLen] === emoji) matchLen++;
      if (matchLen >= MIN_MATCH) {
        for (let k = 0; k < matchLen; k++) matches.push({ row, col: col + k });
      }
      col += matchLen;
    }
  }
  // vertical
  for (let col = 0; col < BOARD_SIZE; col++) {
    let row = 0;
    while (row < BOARD_SIZE - (MIN_MATCH - 1)) {
      const emoji = boardToCheck[row][col];
      if (!emoji) { row++; continue; }
      let matchLen = 1;
      while (row + matchLen < BOARD_SIZE && boardToCheck[row + matchLen][col] === emoji) matchLen++;
      if (matchLen >= MIN_MATCH) {
        for (let k = 0; k < matchLen; k++) matches.push({ row: row + k, col });
      }
      row += matchLen;
    }
  }
  return Array.from(new Set(matches.map(m => `${m.row},${m.col}`))).map(coord => {
    const [r, c] = coord.split(',').map(Number);
    return { row: r, col: c };
  });
}

// Menambahkan skor
function addScore(points) {
  score += points;
  const newLevel = Math.floor(score / LEVEL_UP_SCORE) + 1;

  // Update progress bar
  const progress = (score % LEVEL_UP_SCORE) / LEVEL_UP_SCORE * 100;
  progressBar.style.width = `${progress}%`;

  if (newLevel > level) {
    level = newLevel;
    showLevelUpModal();
  }

  updateDisplay();
}

// Memperbarui tampilan skor dan level
function updateDisplay() {
  scoreDisplay.textContent = score;
  levelDisplay.textContent = level;
}

// Memperbarui jumlah gerakan
function updateMoves() {
  movesDisplay.textContent = moves;
}

// Menampilkan notifikasi kombo
function showComboNotification(combo, points) {
  const notification = document.createElement('div');
  notification.className = 'combo-notification';
  notification.textContent = `Combo x${combo}! +${points}`;
  // pos di tengah layar (relatif)
  notification.style.left = '50%';
  notification.style.top = '30%';
  notification.style.transform = 'translateX(-50%)';
  document.body.appendChild(notification);

  setTimeout(() => {
    if (notification.parentNode) notification.parentNode.removeChild(notification);
  }, 1000);
}

// Menampilkan modal level up
function showLevelUpModal() {
  newLevelDisplay.textContent = level;
  levelUpModal.classList.add('active');
}

// Menutup modal
function closeModal() {
  levelUpModal.classList.remove('active');
}

// Mengacak papan (sinkron & pastikan valid)
function shuffleBoard() {
  if (isProcessing) return;
  isProcessing = true;
  gameBoard.classList.add('processing');

  let allEmojis = [];
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      allEmojis.push(board[r][c] || getRandomEmoji());
    }
  }

  // Fisher-Yates
  for (let i = allEmojis.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [allEmojis[i], allEmojis[j]] = [allEmojis[j], allEmojis[i]];
  }

  let idx = 0;
  for (let r = 0; r < BOARD_SIZE; r++) {
    for (let c = 0; c < BOARD_SIZE; c++) {
      board[r][c] = allEmojis[idx++];
    }
  }

  // pastikan valid: jika masih ada match atau tidak ada valid moves, ulangi shuffle (maks 6 kali)
  let attempts = 0;
  while ((checkAllMatches().length > 0 || !hasValidMovesForBoard(board)) && attempts < 6) {
    // ulangi shuffle
    for (let i = allEmojis.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allEmojis[i], allEmojis[j]] = [allEmojis[j], allEmojis[i]];
    }
    idx = 0;
    for (let r = 0; r < BOARD_SIZE; r++) {
      for (let c = 0; c < BOARD_SIZE; c++) {
        board[r][c] = allEmojis[idx++];
      }
    }
    attempts++;
  }

  updateBoardView();
  isProcessing = false;
  gameBoard.classList.remove('processing');
}
// Menampilkan petunjuk
function showHint() {
  if (isProcessing) return;

  // cari move valid dan highlight
  for (let row = 0; row < BOARD_SIZE; row++) {
    for (let col = 0; col < BOARD_SIZE; col++) {
      // ke kanan
      if (col < BOARD_SIZE - 1) {
        swapCells(board, row, col, row, col + 1);
        if (checkMatchesOnBoard(board).length > 0) {
          swapCells(board, row, col, row, col + 1);
          highlightHint(row, col, row, col + 1);
          return;
        }
        swapCells(board, row, col, row, col + 1);
      }
      // ke bawah
      if (row < BOARD_SIZE - 1) {
        swapCells(board, row, col, row + 1, col);
        if (checkMatchesOnBoard(board).length > 0) {
          swapCells(board, row, col, row + 1, col);
          highlightHint(row, col, row + 1, col);
          return;
        }
        swapCells(board, row, col, row + 1, col);
      }
    }
  }
}

// Menyoroti petunjuk
function highlightHint(row1, col1, row2, col2) {
  const elements = [
    document.querySelector(`.emoji[data-row="${row1}"][data-col="${col1}"]`),
    document.querySelector(`.emoji[data-row="${row2}"][data-col="${col2}"]`)
  ];

  elements.forEach(el => {
    if (el) {
      const highlight = document.createElement('div');
      highlight.className = 'highlight';
      el.appendChild(highlight);
    }
  });

  // Hapus sorotan setelah 1 detik
  setTimeout(() => {
    elements.forEach(el => {
      if (el) {
        const h = el.querySelector('.highlight');
        if (h) el.removeChild(h);
      }
    });
  }, 1000);
}

// Inisialisasi game saat halaman dimuat
window.addEventListener('load', initGame);
</script>
</body>
</html>
